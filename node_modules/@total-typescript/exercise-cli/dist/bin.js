#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve4, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve4(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/command.ts
var import_commander = require("commander");

// src/runExercise.ts
var path4 = __toESM(require("path"));

// src/detectExerciseType.ts
var import_promises = __toESM(require("fs/promises"));
var import_path = __toESM(require("path"));
var endsWithTsOrTsx = (filepath) => filepath.endsWith(".ts") || filepath.endsWith(".tsx");
var isDir = (filepath) => __async(void 0, null, function* () {
  const stat = yield import_promises.default.stat(filepath);
  return stat.isDirectory();
});
var detectExerciseType = (filepath) => __async(void 0, null, function* () {
  var _a;
  if (endsWithTsOrTsx(filepath)) {
    return "file";
  }
  if (yield isDir(filepath)) {
    const packageJsonPath = import_path.default.resolve(filepath, "package.json");
    try {
      const packageJson = yield import_promises.default.readFile(packageJsonPath, "utf-8");
      const parsed = JSON.parse(packageJson);
      if ((_a = parsed == null ? void 0 : parsed.scripts) == null ? void 0 : _a.dev) {
        return "package-json-with-dev-script";
      }
    } catch (e) {
    }
  }
  return "not-runnable";
});

// src/runFileBasedExercise.ts
var import_child_process = require("child_process");
var chokidar = __toESM(require("chokidar"));
var fs2 = __toESM(require("fs/promises"));
var import_jsonc_parser = require("jsonc-parser");
var path2 = __toESM(require("path"));
var runFileBasedExercise = (exerciseFile) => __async(void 0, null, function* () {
  const tempTsconfigPath = path2.resolve(process.cwd(), "./tsconfig.temp.json");
  const tsconfigPath = path2.resolve(process.cwd(), "./tsconfig.json");
  const tsconfig = (0, import_jsonc_parser.parse)(yield fs2.readFile(tsconfigPath, "utf8"));
  chokidar.watch(exerciseFile).on("all", () => __async(void 0, null, function* () {
    const fileContents = yield fs2.readFile(exerciseFile, "utf8");
    const containsVitest = fileContents.includes(`from "vitest"`) || fileContents.includes(`from 'vitest'`);
    try {
      console.clear();
      if (containsVitest) {
        console.log("Running tests...");
        (0, import_child_process.execSync)(`vitest run "${exerciseFile}" --passWithNoTests`, {
          stdio: "inherit"
        });
      }
      console.log("Checking types...");
      const tsconfigWithIncludes = __spreadProps(__spreadValues({}, tsconfig), {
        include: [exerciseFile]
      });
      yield fs2.writeFile(
        tempTsconfigPath,
        JSON.stringify(tsconfigWithIncludes, null, 2)
      );
      const cmd = `tsc --project "${tempTsconfigPath}"`;
      (0, import_child_process.execSync)(cmd, {
        stdio: "inherit"
      });
      console.log("Typecheck complete. You finished the exercise!");
    } catch (e) {
      console.log("Failed. Try again!");
      try {
        yield fs2.rm(tempTsconfigPath);
      } catch (e2) {
      }
    }
  }));
});

// src/runPackageJsonExercise.ts
var import_child_process2 = require("child_process");
var runPackageJsonExercise = (exerciseFile) => __async(void 0, null, function* () {
  (0, import_child_process2.execSync)("pnpm install", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
  (0, import_child_process2.execSync)("pnpm run dev", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
});

// src/findAllExercises.ts
var fg = __toESM(require("fast-glob"));
var import_path2 = __toESM(require("path"));
var searchToGlob = (search) => {
  var _a, _b, _c;
  return `**/${(_a = search == null ? void 0 : search.num) != null ? _a : ""}*.{${(_c = (_b = search == null ? void 0 : search.allowedTypes) == null ? void 0 : _b.join(",")) != null ? _c : ""}}*`;
};
var findAllExercises = (srcPath, search) => __async(void 0, null, function* () {
  const glob = searchToGlob(search || {});
  const allExercises = yield fg.default(
    import_path2.default.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises;
});
var findExercise = (srcPath, search) => __async(void 0, null, function* () {
  const glob = searchToGlob(search);
  const allExercises = yield fg.default(
    import_path2.default.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises[0];
});

// src/runExercise.ts
var findExerciseToRun = (exercise, runSolution) => __async(void 0, null, function* () {
  const srcPath = path4.resolve(process.cwd(), "./src");
  const exerciseFile = yield findExercise(srcPath, {
    num: exercise,
    allowedTypes: ["explainer", runSolution ? "solution" : "problem"]
  });
  if (!exerciseFile) {
    console.log(`Exercise ${exercise} not found`);
    process.exit(1);
  }
  return exerciseFile;
});
var runExercise = (exercise, runSolution) => __async(void 0, null, function* () {
  if (!exercise) {
    console.log("Please specify an exercise");
    process.exit(1);
  }
  const exerciseFile = yield findExerciseToRun(exercise, runSolution);
  const exerciseType = yield detectExerciseType(exerciseFile);
  if (exerciseType === "not-runnable") {
    console.log(
      `Exercise ${exercise} is not runnable. Follow the instructions in the video to complete it.`
    );
    process.exit(0);
  }
  switch (exerciseType) {
    case "file":
      return yield runFileBasedExercise(exerciseFile);
    case "package-json-with-dev-script":
      return yield runPackageJsonExercise(exerciseFile);
  }
  exerciseType;
});

// src/prepareStackblitz.ts
var fs3 = __toESM(require("fs/promises"));
var path5 = __toESM(require("path"));
var prepareStackblitz = () => __async(void 0, null, function* () {
  const packageJsonPath = path5.resolve(process.cwd(), "package.json");
  const packageJson = JSON.parse(yield fs3.readFile(packageJsonPath, "utf8"));
  const srcPath = path5.resolve(process.cwd(), "./src");
  const exerciseFiles = yield findAllExercises(srcPath, {
    allowedTypes: ["problem", "explainer"]
  });
  const exerciseNames = exerciseFiles.map(
    (exercise) => path5.parse(exercise).base.split("-")[0]
  );
  const newPackageJson = Object.assign({}, packageJson);
  newPackageJson.scripts = __spreadValues({}, packageJson.scripts);
  exerciseNames.forEach((exercise) => {
    newPackageJson.scripts[`e-${exercise}`] = `tt-cli run ${exercise}`;
    newPackageJson.scripts[`s-${exercise}`] = `tt-cli run ${exercise} --solution`;
  });
  yield fs3.writeFile(packageJsonPath, JSON.stringify(newPackageJson, null, 2));
});

// src/command.ts
var program = new import_commander.Command();
program.version("0.0.1");
program.command("run <exercise>").alias("exercise <exercise>").description("Runs an exercise on watch mode").option("-s, --solution", "Run the solution").action(
  (exercise, options) => runExercise(exercise, options.solution)
);
program.command("prepare-stackblitz").description("Adds e-01, e-02 scripts to package.json").action(prepareStackblitz);

// src/bin.ts
program.parse();
